!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Tests parallel log single rank output option handling.
!>

module log_mod_parallel_rank_limit_test

  use constants_mod, only: i_def, str_long
  use log_mod,       only: finalise_logging, initialise_logging, log_event, &
                           log_level_debug, log_level_error,                &
                           log_level_info, log_level_trace,                 &
                           log_level_warning, log_set_alert_stream,         &
                           log_set_level, log_set_info_stream,              &
                           log_forget_timestep
  use pfunit

  implicit none

  private

  public log_output_test_single_debug, &
         log_output_test_debug_sole_numbered_rank_zero
  !
  ! pFUnit requires symbol spill
  !
  public :: MPITestCase, MPITestParameter

  integer(i_def), parameter :: log_unit   = 11
  integer(i_def), parameter :: info_unit  = 12
  integer(i_def), parameter :: alert_unit = 13

  @testCase
  type, public, extends(MpiTestCase) :: log_test_type
    character(:), allocatable :: pet_file
  contains
    procedure :: setUp
    procedure :: tearDown
  end type log_test_type

  character(*), parameter :: name = 'log_mod_rank_unit_test'

contains

  subroutine setUp( this )

    implicit none

    class(log_test_type), intent(inout) :: this

    character(str_long) :: str_filename
    integer(i_def)      :: status

    if (this%getNumProcesses() > 1) then
      write( str_filename, &
             '("PET", I0, ".", A, ".Log")') this%getProcessRank(), name
      this%pet_file = str_filename

      open( log_unit, file=this%pet_file, action='write', iostat=status )
      if (status == 0) close( log_unit, status='delete' )
    end if

  end subroutine setUp


  subroutine tearDown( this )

    implicit none

    class(log_test_type), intent(inout) :: this

    integer(i_def) :: status

    if (allocated(this%pet_file)) then
      open( log_unit, file=this%pet_file, action='write', iostat=status )
      if (status == 0) close( log_unit, status='delete' )
    end if

  end subroutine tearDown


  @test(npes=[1])
  subroutine log_output_test_single_debug( context )

    implicit none

    class(log_test_type), intent(inout) :: context

    call initialise_logging( context%getMpiCommunicator(), name, &
                             log_to_rank_zero_only=.true. )
    call log_forget_timestep()
    call log_output_test_serial( log_level_debug, ':DEBUG:' )
    call finalise_logging()

  end subroutine log_output_test_single_debug


  @test(npes=[2, 3, 4])
  subroutine log_output_test_debug_sole_numbered_rank_zero( context )

    implicit none

    class(log_test_type), intent(inout) :: context
    integer(i_def) :: this_rank

    ! initialise logger with sole rank limit on
    call initialise_logging( context%getMpiCommunicator(), name, &
                             log_to_rank_zero_only=.true. )
    call log_forget_timestep()
    this_rank = context%getProcessRank()
    ! Validate that rank 0 outputs the expected log information
    if (this_rank == 0) then
      call log_output_test( context%getProcessRank(), log_level_debug, &
                            expected_tag=':DEBUG :' )
    else
      ! validate that all other ranks produce no file
      call log_output_test_exists( context%getProcessRank(), exists=.false. )
    endif

  end subroutine log_output_test_debug_sole_numbered_rank_zero


  !> Test the default behaviour of the logger.
  !>
  !> As part of the test system redirecting the output to alternate units is
  !> also tested.
  !>
  subroutine log_output_test( thread, level, expected_tag )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: thread
    integer(i_def), intent(in) :: level
    character(*),   intent(in) :: expected_tag

    ! Must hold 14 digits:
    integer(i_def), parameter :: i_time = selected_int_kind( 14 )

    integer(i_time)   :: current_stamp
    character(28)     :: current_date_string
    integer(i_def)    :: current_subseconds
    integer(i_def)    :: current_zone
    character(3)      :: expected_proc
    integer(i_time)   :: found_stamp
    character         :: found_point
    integer(i_def)    :: found_subseconds
    integer(i_def)    :: found_zone
    character(3)      :: found_proc
    character(8)      :: found_tag
    character(80)     :: found_message
    integer(i_def)    :: status
    character(40)     :: filename

    call date_and_time( date=current_date_string(1:8), &
                        time=current_date_string(9:18), &
                        zone=current_date_string(19:) )
    read( current_date_string, "(I14,1X,I3,I5)" ) current_stamp, &
                                                  current_subseconds, &
                                                  current_zone

    call log_set_level( log_level_info )

    call log_event('cheese', level)

    call finalise_logging()

    write( filename, '("PET", I0, ".", A, ".Log")') thread, name
    open( log_unit, file=filename, action='read', iostat=status )
    @assertEqual( 0, status )
    rewind(log_unit)

    write( expected_proc, '(":P", I0)' ) thread

    read( log_unit, '(I14,A1,I3,I5,A3,A8,A)', iostat = status ) &
        found_stamp, found_point, found_subseconds, found_zone, &
        found_proc, found_tag, found_message
    if ( level >= LOG_LEVEL_INFO ) then
      @assertEqual( 0,             status )
      @assertEqual( '.',           found_point )
      @assertEqual( expected_proc, found_proc )
      @assertEqual( expected_tag,  found_tag )
      @assertEqual( 'cheese',      found_message )
      @assertTrue( current_stamp <= found_stamp )
      @assertEqual( current_zone,  found_zone )
    else
      @assertEqual( iostat_end,   status )
    end if

    close( log_unit, status='delete' )

  end subroutine log_output_test


  !> Test the default behaviour of the logger.
  !>
  !> As part of the test system redirecting the output to alternate units is
  !> also tested.
  !>
  subroutine log_output_test_serial( level, expected_tag )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: level
    character(*),      intent(in) :: expected_tag

    integer(i_def), parameter :: date_kind = selected_int_kind( 14 )

    integer( kind=date_kind ) :: current_stamp
    character(28)             :: current_date_string
    integer(i_def)            :: current_subseconds
    integer(i_def)            :: current_zone
    integer( kind=date_kind)  :: found_stamp
    character(1)              :: found_point
    integer(i_def)            :: found_subseconds
    integer(i_def)            :: found_zone
    character(8)              :: found_tag
    character(80)             :: found_message
    integer(i_def)         :: status

    open( INFO_UNIT, status='scratch', action='readwrite', iostat=status )
    @assertEqual( 0, status )

    open( ALERT_UNIT, status='scratch', action='readwrite', iostat=status )
    @assertEqual( 0, status )

    call date_and_time( date=current_date_string(1:8), &
                        time=current_date_string(9:18), &
                        zone=current_date_string(19:) )
    read( current_date_string, "(I14,1X,I3,I5)" ) current_stamp, &
                                                  current_subseconds, &
                                                  current_zone

    call log_set_info_stream(INFO_UNIT)
    call log_set_alert_stream(ALERT_UNIT)

    call log_set_level( log_level_info )

    call log_event('cheese', level)

    rewind(INFO_UNIT)
    read( INFO_UNIT, '(I14,A1,I3,I5,A8,A)', iostat = status ) &
        found_stamp, found_point, found_subseconds, found_zone, &
        found_tag, found_message
    if ( ( level >= LOG_LEVEL_INFO ) &
         .and. ( level < LOG_LEVEL_WARNING ) ) then
      @assertEqual( 0,            status )
      @assertEqual( '.',          found_point )
      @assertEqual( expected_tag, found_tag )
      @assertEqual( 'cheese',     found_message )
      @assertTrue( current_stamp <= found_stamp )
      @assertEqual( current_zone, found_zone )
    else
      @assertEqual( iostat_end,        status )
    end if

    rewind( ALERT_UNIT )
    read( ALERT_UNIT, '(I14,A1,I3,I5,A8,A)', iostat = status ) &
        found_stamp, found_point, found_subseconds, found_zone, &
        found_tag, found_message
    if ( level >= LOG_LEVEL_WARNING ) then
      @assertEqual( 0,            status )
      @assertEqual( '.',          found_point )
      @assertEqual( expected_tag, found_tag )
      @assertEqual( 'cheese',     found_message )
      @assertTrue( current_stamp <= found_stamp )
      @assertEqual( current_zone, found_zone )
    else
      @assertEqual( iostat_end,        status )
    end if

    close( ALERT_UNIT, iostat=status )
    @assertEqual( 0, status )
    close( INFO_UNIT, iostat=status )
    @assertEqual( 0, status )

  end subroutine log_output_test_serial


  !> Test that log file is produced or not
  !>
  subroutine log_output_test_exists( thread, exists )

    use, intrinsic :: iso_fortran_env, only : iostat_end

    implicit none

    integer(i_def), intent(in) :: thread
    character(40)              :: filename
    logical, intent(in)        :: exists
    logical                     :: res

    call finalise_logging()

    write( filename, '("PET", I0, ".", A, ".Log")') thread, name

    ! Check if the file exists
    inquire( file=trim(filename), exist=res )
    if ( exists ) then
      @assertTrue( res )
    else
      @assertFalse( res )
    endif
    close( log_unit, status='delete' )

  end subroutine log_output_test_exists


end module log_mod_parallel_rank_limit_test
