!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Algorithms to produce diagnsotics
module diagnostic_alg_mod
   use constants_mod,                 only: i_def, r_def
   use finite_element_config_mod,     only: element_order
   use function_space_collection_mod, only: function_space_collection
   use output_config_mod,             only : write_nodal_output, &
                                             write_xios_output
   use io_mod,                        only : output_nodal, &
                                             output_xios_nodal, &
                                             xios_write_field_face
   implicit none

   private
   public :: divergence_diagnostic_alg
   public :: pressure_diagnostic_alg
   public :: density_diagnostic_alg
   public :: hydbal_diagnostic_alg

contains

  !> @details Calculates the l2 error norm for wind divergence and outputs to
  !> file the wind divergence field.
  !> @param[in] u       3D wind fieldDensity
  !> @param[in] t       Timestep
  !> @param[in] mesh_id Mesh_id
  subroutine divergence_diagnostic_alg(u, t, mesh_id)
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use runtime_constants_mod,       only: get_mass_matrix, &
                                           get_div, &
                                           w3inv_id
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type, write_interface
    use fs_continuity_mod,           only: W3
    use log_mod,                     only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_INFO

    implicit none 
    type(field_type), intent(in) :: u
    integer(i_def),   intent(in) :: t, mesh_id

    type(field_type)             :: divergence, div_u
    type(operator_type), pointer :: div => null(), m3_inv => null()
    real(r_def)                  :: l2

    procedure(write_interface), pointer  :: tmp_ptr

    divergence =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div_u      =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div    => get_div()
    m3_inv => get_mass_matrix(w3inv_id)
    call invoke( dg_matrix_vector_kernel_type( div_u, u, div ), &

    ! Compute l2 norm of area integrated quantity
                 X_innerproduct_X( l2, div_u ) )
    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of divergence =',sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )


    ! Convert to pointwise W3 field for output
    call invoke( dg_matrix_vector_kernel_type( divergence, div_u , m3_inv ) )

    ! Check what output options have been requested and call them
 
    if (write_nodal_output) then
      call output_nodal('divergence',   t, divergence,   mesh_id)
    end if 

    if (write_xios_output) then
      !If using XIOS, we need to set the field IO method appropriately
      tmp_ptr => xios_write_field_face
      call divergence%set_write_field_behaviour(tmp_ptr)
      if (t == 0) then
        call divergence%write_field('init_divergence')
      else
        call divergence%write_field('divergence')
      end if
    end if 

    nullify( div, m3_inv, tmp_ptr )

  end subroutine divergence_diagnostic_alg

!=============================================================================!
  !> @details Algorithm which outputs of file the exner pressure field.
  !> @param[in] rho     Density
  !> @param[in] theta   Potential temperature
  !> @param[in] t       Timestep
  !> @param[in] mesh_id Mesh_id
  subroutine pressure_diagnostic_alg(rho, theta, t, mesh_id)
    use runtime_constants_mod,        only: get_mass_matrix, &
                                            get_qr, &
                                            get_coordinates, &
                                            w3inv_id
    use operator_mod,                 only: operator_type
    use field_mod,                    only: field_type, write_interface
    use project_pressure_kernel_mod,  only: project_pressure_kernel_type
    use quadrature_xyoz_mod,          only: quadrature_xyoz_type
    implicit none 

    type(field_type), intent(in) :: rho, theta
    integer(i_def),   intent(in) :: t, mesh_id

    type(field_type)             :: exner
    type(operator_type), pointer :: m3_inv => null()
    type(quadrature_xyoz_type)   :: qr
    type(field_type), pointer    :: chi(:) => null()

    procedure(write_interface), pointer :: tmp_ptr

    m3_inv => get_mass_matrix(w3inv_id)
    qr = get_qr()
    chi => get_coordinates()
    exner = field_type( vector_space = rho%get_function_space() )
    call invoke( project_pressure_kernel_type( exner, rho, theta, &
                                               chi, m3_inv, qr ) )

    ! Check what output options have been requested and call them
 
    if (write_nodal_output) then
      call output_nodal('exner',   t, exner,   mesh_id)
    end if 

    if (write_xios_output) then
      ! If using XIOS, we need to set the field IO method appropriately
      tmp_ptr => xios_write_field_face
      call exner%set_write_field_behaviour(tmp_ptr)
      if (t == 0) then
        call exner%write_field('init_exner')
      else
        call exner%write_field('exner')
      end if
    end if 

    nullify( m3_inv, chi, tmp_ptr )

  end subroutine pressure_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 error for the density field.
  !>          It is capable of calculating the error at each timestep by using
  !>          set_rho_alg algorithm which will return the analytic density value
  !>          at each timestep.
  !> @param[in] rho_num  Density
  !> @param[in] timestep Timestep
  subroutine density_diagnostic_alg(rho_num, timestep)
    use runtime_constants_mod,        only: get_qr, &
                                            get_coordinates
    use operator_mod,                 only: operator_type
    use field_mod,                    only: field_type
    use quadrature_xyoz_mod,          only: quadrature_xyoz_type
    use set_rho_alg_mod,              only: set_rho_alg
    use log_mod,                      only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
    use runtime_constants_mod,        only: get_mass_matrix, w3_id


    implicit none

    type(field_type), intent(in) :: rho_num
    integer(i_def),   intent(in) :: timestep

    type(field_type)             :: rho_analytic
    type(field_type)             :: rho_diff
    type(field_type)             :: w3_rho_diff
    type(field_type)             :: w3_rho_analytic
    type(quadrature_xyoz_type)   :: qr

    type(field_type), pointer    :: chi(:) => null()
    real(r_def)                  :: sum_diff, sum_analytic
    type(operator_type), pointer :: mm_w3 => null()

    qr = get_qr()
    chi => get_coordinates()

    rho_analytic = field_type( vector_space = rho_num%get_function_space() )
    rho_diff     = field_type( vector_space = rho_num%get_function_space() )
    w3_rho_diff  = field_type( vector_space = rho_num%get_function_space() )
    w3_rho_analytic  = field_type( vector_space = rho_num%get_function_space() )

    mm_w3 => get_mass_matrix(w3_id)

    call set_rho_alg( rho_analytic, timestep)

    ! The normalised l2 error norm with cell volume weightings is calculated as:
    ! l2 = sqrt(I((rho_num - rho_analytic)^2))/sqrt(I(rho_analtyic^2))
    ! where I(rho) = sum(rho_i*volume_of_cell_i).
    ! Here we let sum_diff = I((rho_num - rho_analytic)^2)
    ! and         sum_analytic = I(rho_analtyic^2)
    ! To calculate sum_diff we use the inner product operator and multiply one of
    ! the differences by the W3 matrix which contains the cell volumes.
    ! sum_diff = inner_product( rho_num-rho_analytic, W3*(rho_num-rho_analytic))
    ! Similarly for sum_analytic the following is calculated:
    ! sum_analytic = inner_product( rho_analytic, W3*rho_analytic)

    call invoke( X_minus_Y( rho_diff, rho_num, rho_analytic ),                            &
                 dg_matrix_vector_kernel_type( w3_rho_diff, rho_diff , mm_w3 ),           &
                 X_innerproduct_Y( sum_diff, w3_rho_diff, rho_diff ),                     &
                 dg_matrix_vector_kernel_type( w3_rho_analytic, rho_analytic , mm_w3 ),   &
                 X_innerproduct_Y( sum_analytic, w3_rho_analytic, rho_analytic ) )

    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of rho difference =',sqrt(sum_diff)/sqrt(sum_analytic)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

    nullify( chi )
    nullify( mm_w3 )

  end subroutine density_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 norm for the hydrostatic
  !>          imbalance. It calculates the sum of pressure gradient and
  !>          gravity term at each timestep using the hydrostatic kernel.
  !> @param[in] theta   Potential temperature
  !> @param[in] exner   Exner pressure
  !> @param[in] mesh_id Mesh_id
  subroutine hydbal_diagnostic_alg(theta, exner, mesh_id)
    use field_mod,                   only: field_type
    use quadrature_xyoz_mod,         only: quadrature_xyoz_type
    use fs_continuity_mod,           only: W2V
    use psykal_lite_mod,             only: invoke_inner_prod
    use log_mod,                     only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_INFO

    ! PsyKAl PSYClone kernels
    use enforce_bc_kernel_mod,               only: enforce_bc_kernel_type
    use hydrostatic_kernel_mod,              only: hydrostatic_kernel_type
    use runtime_constants_mod,               only: get_geopotential,         &
                                                   get_qr


    implicit none
    type(field_type), intent(in) :: theta, exner
    type(field_type), pointer    :: geopotential => null()
    type(field_type)             :: hyd_imbal
    integer(i_def),   intent(in) :: mesh_id

    ! the quadrature object
    type( quadrature_xyoz_type ) :: qr

    real(r_def)                  :: l2

    hyd_imbal =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W2V) )

    qr = get_qr()

    ! Get geopotential field from runtime_constants
    geopotential => get_geopotential()

    call invoke( setval_c(hyd_imbal, 0.0_r_def), &
                 hydrostatic_kernel_type( hyd_imbal, exner, theta, geopotential, qr ), & 
                 enforce_bc_kernel_type( hyd_imbal ), &
                 X_innerproduct_X(l2, hyd_imbal) )
    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of hydrostatic imbalance =',sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

  end subroutine hydbal_diagnostic_alg

end module diagnostic_alg_mod
