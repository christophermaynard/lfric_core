!-------------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
!-------------------------------------------------------------------------------
!
!> @brief Provides various geometric objects for use throughout gungho.
!>
!> @details This module controls the set-up of various objects relating to
!>          the geometry of the mesh that do not change during a run. These
!>          objects are accessed from this module through appropriate 'get'
!>          functions.
!-------------------------------------------------------------------------------

module geometric_constants_mod

  ! Infrastructure
  use constants_mod,                      only: i_def, r_def
  use field_mod,                          only: field_type
  use fs_continuity_mod,                  only: W0, W2, W3, Wtheta, Wchi
  use function_space_chain_mod,           only: multigrid_function_space_chain, &
                                                single_layer_function_space_chain
  use function_space_collection_mod,      only: function_space_collection
  use function_space_mod,                 only: function_space_type
  use io_config_mod,                      only: subroutine_timers
  use log_mod,                            only: log_event, LOG_LEVEL_INFO, &
                                                LOG_LEVEL_ERROR
  use mesh_mod,                           only: mesh_type
  use quadrature_xyoz_mod,                only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,       only: quadrature_rule_gaussian_type
  use timer_mod,                          only: timer

  ! Configuration
  use base_mesh_config_mod,               only: f_lat, geometry, &
                                                geometry_spherical
  use finite_element_config_mod,          only: element_order, nqp_exact, &
                                                spherical_coord_order
  use formulation_config_mod,             only: l_multigrid
  use multigrid_config_mod,               only: multigrid_chain_nitems

  use transport_config_mod,               only: scheme,                 &
                                                scheme_method_of_lines, &
                                                rho_splitting,          &
                                                rho_splitting_none,     &
                                                theta_splitting,        &
                                                theta_splitting_none

  ! Routines to assign coordinates and orography
  use assign_coordinate_field_mod,        only: assign_coordinate_field
  use assign_orography_field_mod,         only: assign_orography_field

  ! Kernels
  use calc_dA_at_w2_kernel_mod,           only: calc_dA_at_w2_kernel_type
  use compute_latlon_kernel_mod,          only: compute_latlon_kernel_type
  use get_height_kernel_mod,              only: get_height_kernel_type
  use psykal_lite_mod,                    only: invoke_mpi_calc_cell_orientation
  use restrict_kernel_mod,                only: restrict_kernel_type

  implicit none

  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them

  ! Mesh IDs
  integer(i_def), target                                 :: global_shifted_mesh_id
  integer(i_def), target                                 :: global_double_level_mesh_id

  ! Panel ID fields
  type(field_type), allocatable, dimension(:), target    :: panel_id_mg

  ! Coordinate fields
  type(field_type), allocatable, dimension(:,:), target  :: chi_mg
  type(field_type), allocatable, dimension(:), target    :: chi_xyz
  type(field_type), target, dimension(:), allocatable    :: chi_sph_shifted
  type(field_type), target, dimension(:), allocatable    :: chi_xyz_shifted
  type(field_type), target, dimension(:), allocatable    :: chi_sph_double_level
  type(field_type), target, dimension(:), allocatable    :: chi_xyz_double_level
  type(field_type), allocatable, dimension(:), target    :: surface_altitude_mg

  ! Other geometric objects
  type(field_type), target                               :: cell_orientation
  type(field_type), target                               :: cell_orientation_shifted
  type(field_type), target                               :: dA_at_w2
  type(field_type), target                               :: dA_at_w2_shifted
  type(field_type), target                               :: dA_at_w2_double_layer
  type(field_type), target                               :: height_w3
  type(field_type), target                               :: height_wth
  type(field_type), target                               :: lat_w3, long_w3

  ! Public functions to create and access the module contents

  public :: create_geometric_constants
  public :: final_geometric_constants
  public :: get_panel_id
  public :: get_shifted_mesh_id
  public :: get_double_level_mesh_id
  public :: get_coordinates
  public :: get_coordinates_xyz
  public :: get_coordinates_shifted
  public :: get_coordinates_xyz_shifted
  public :: get_coordinates_double_layer
  public :: get_coordinates_xyz_double_layer
  public :: get_cell_orientation
  public :: get_cell_orientation_shifted
  public :: get_dA_at_w2
  public :: get_dA_at_w2_shifted
  public :: get_dA_at_w2_double_layer
  public :: get_height
  public :: get_latitude
  public :: get_longitude


  ! overload the interfaces for MG versions
  interface get_coordinates
     module procedure get_coordinates_fine, get_coordinates_mg
  end interface get_coordinates

  interface get_panel_id
     module procedure get_panel_id_fine, get_panel_id_mg
  end interface get_panel_id


contains

  !>@brief Subroutine to create the geometric constants
  !> @param[in] mesh_id              Mesh_id
  !> @param[in] twod_mesh_id         Mesh_id for 2D domain
  !> @param[in] chi_xyz_in           xyz chi field
  !> @param[in] chi_sph              spherically-based chi field
  !> @param[in] panel_id             panel id
  !> @param[in] shifted_mesh_id      Mesh_id for vertically shifted field
  !> @param[in] shifted_chi_xyz      xyz chi field for vertically shifted field
  !> @param[in] shifted_chi_sph      spherical chi field for vertically shifted field
  !> @param[in] double_level_mesh_id Mesh_id for double level field
  !> @param[in] double_level_chi_xyz xyz chi field for double level field
  !> @param[in] double_level_chi_sph spherical chi field for double level field
  !> @param[in] surface_altitude     A 2D field describing the surface height
  subroutine create_geometric_constants(mesh_id, twod_mesh_id, &
                                        chi_xyz_in, chi_sph,   &
                                        panel_id,              &
                                        shifted_mesh_id,       &
                                        shifted_chi_xyz,       &
                                        shifted_chi_sph,       &
                                        double_level_mesh_id,  &
                                        double_level_chi_xyz,  &
                                        double_level_chi_sph,  &
                                        surface_altitude)
    implicit none

    ! Arguments
    integer(i_def),             intent(in) :: mesh_id, twod_mesh_id
    type(field_type), target,   intent(in) :: chi_xyz_in(:)
    type(field_type), target,   intent(in) :: chi_sph(:)
    type(field_type), target,   intent(in) :: panel_id
    integer(i_def), optional,   intent(in) :: shifted_mesh_id
    type(field_type), optional, intent(in) :: shifted_chi_xyz(:)
    type(field_type), optional, intent(in) :: shifted_chi_sph(:)
    integer(i_def), optional,   intent(in) :: double_level_mesh_id
    type(field_type), optional, intent(in) :: double_level_chi_xyz(:)
    type(field_type), optional, intent(in) :: double_level_chi_sph(:)
    type(field_type), optional, intent(in) :: surface_altitude

    ! Internal variables
    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()
    type(function_space_type), pointer :: wtheta_fs => null()
    type(function_space_type), pointer :: wth_k0_fs => null() ! lowest order wth fs
    type(function_space_type), pointer :: w3_k0_fs  => null() ! lowest order w3 fs
    type(function_space_type), pointer :: w3_k0_2d_fs => null() ! lowest order w3 fs
    type(field_type)                   :: temp_w2_field
    type(field_type)                   :: temp_w2_field_shifted

    ! Quadrature objects
    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule

    ! temporaries needed for Multigrid
    integer(kind=i_def) :: i, level, chi_space, multigrid_levels
    integer(kind=i_def) :: mg_mesh_id
    integer(kind=i_def) :: surface_order

    ! Logical changes depending on presence of optional argument
    logical :: use_surface_altitude


    if ( subroutine_timers ) call timer('geometric_constants_alg')
    call log_event( "Gungho: creating geometric_constants", LOG_LEVEL_INFO )

    use_surface_altitude=.false.
    if (present(surface_altitude)) use_surface_altitude=.true.

    if(l_multigrid) then
       multigrid_levels=multigrid_chain_nitems
    else
       multigrid_levels=1
    end if

    qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

    !=============== Handling of chi fields and panel ids ===================!

    ! make chi_sph and panel_id accessible
    allocate(chi_xyz(3))
    do i = 1, 3
      call chi_xyz_in(i)%copy_field(chi_xyz(i))
    end do

    ! make the multigrid chi field.
    allocate(chi_mg(3,multigrid_levels))
    allocate(panel_id_mg(multigrid_levels))
    do i = 1, 3
       call chi_sph(i)%copy_field(chi_mg(i,1))
    end do
    call panel_id%copy_field(panel_id_mg(1))

    if ( use_surface_altitude ) then
      allocate(surface_altitude_mg(multigrid_levels))
      call surface_altitude%copy_field(surface_altitude_mg(1))
    end if
    ! Compute coordinates
    if ( spherical_coord_order == 0 ) then
       chi_space = W0
       call log_event( "geometric_constants: Computing W0 coordinate fields for MG", LOG_LEVEL_INFO )
    else
       chi_space = Wchi
       call log_event( "geometric_constants: Computing Wchi coordinate fields for MG", LOG_LEVEL_INFO )
    end if

    if ( l_multigrid ) then

      if ( use_surface_altitude ) then
        ! get the mesh_id from the other function space
        ! need to get the mesh_id to create the chi fs, so get it from the W3 chain
        ! First for the surface altitude on single layer fields
        surface_order = surface_altitude%get_element_order()
        w3_fs => function_space_collection%get_fs( twod_mesh_id, surface_order, W3 )
        call single_layer_function_space_chain%set_current( w3_fs%get_id() )
        do level = 2, multigrid_levels
          ! Get the surface altitude by restricting the finest level
          w3_fs => single_layer_function_space_chain%get_next()
          mg_mesh_id = w3_fs%get_mesh_id()
          call surface_altitude_mg( level )%initialise( vector_space = &
             function_space_collection%get_fs(                         &
             mg_mesh_id, surface_order, W3) )
          ! We use a simple restriction from fine to coarse levels
          call invoke( restrict_kernel_type( surface_altitude_mg( level ),   &
                                             surface_altitude_mg( level-1 ) ) )
        end do
      end if

      ! get the mesh_id from the other function space
      ! need to get the mesh_id to create the chi fs, so get it from the W3 chain
      ! Now the chi fields
      w3_fs => function_space_collection%get_fs( mesh_id, element_order, W3 )
      call multigrid_function_space_chain%set_current( w3_fs%get_id() )
      ! finest level is already done, so loop through levels 2, multigrid_levels
      do level = 2, multigrid_levels
        w3_fs => multigrid_function_space_chain%get_next()
        mg_mesh_id = w3_fs%get_mesh_id()
        do i = 1, 3
          call chi_mg( i,level )%initialise( vector_space = &
                  function_space_collection%get_fs(         &
                  mg_mesh_id, spherical_coord_order, chi_space) )
        end do

        call panel_id_mg(level)%initialise(vector_space = w3_fs )

        call assign_coordinate_field(chi_mg(:,level), panel_id_mg(level), &
                                     mg_mesh_id, spherical_coords=.true.)

        if ( use_surface_altitude ) then
          call assign_orography_field(chi_mg(:,level), panel_id_mg(level),    &
                                      mg_mesh_id, surface_altitude_mg(level), &
                                      spherical_coords=.true. )
        end if
      end do

    end if

    ! set level = 1 for the finest level MG/ or single level only
    level = 1

    !=========== Create function spaces required for setup ===================!

    w2_fs     => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs     => function_space_collection%get_fs( mesh_id, element_order, W3 )
    wtheta_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )
    w3_k0_fs  => function_space_collection%get_fs( mesh_id,             0, W3 )
    wth_k0_fs => function_space_collection%get_fs( mesh_id,             0, Wtheta )
    w3_k0_2d_fs => function_space_collection%get_fs( twod_mesh_id,      0, W3 )

    !=================== Create cell orientation field ========================!

    if (scheme /= scheme_method_of_lines    .or. &
        rho_splitting /= rho_splitting_none .or. &
        theta_splitting /= theta_splitting_none  ) then

      call temp_w2_field%initialise( vector_space = w2_fs )
      call cell_orientation%initialise( vector_space = w3_fs )
      call invoke( setval_c(temp_w2_field,    0.0_r_def), &
                   setval_c(cell_orientation, 0.0_r_def) )
      if ( element_order == 0 ) then
        ! Currently this isn't set up to work with high order dynamics
        call invoke_mpi_calc_cell_orientation( temp_w2_field, cell_orientation )
       else
         call log_event( "Cell orientation not set up for high order elements", &
                          LOG_LEVEL_ERROR )
      end if

      if ( present(shifted_mesh_id) ) then

        call temp_w2_field_shifted%initialise( vector_space =                    &
          function_space_collection%get_fs( shifted_mesh_id, element_order, W2 ) )
        call cell_orientation_shifted%initialise( vector_space =                 &
          function_space_collection%get_fs( shifted_mesh_id, element_order, W3 ) )
        call invoke( setval_c(temp_w2_field_shifted,    0.0_r_def),              &
                     setval_c(cell_orientation_shifted, 0.0_r_def) )
        if ( element_order == 0 ) then
          ! Currently this isn't set up to work with high order dynamics
          call invoke_mpi_calc_cell_orientation( temp_w2_field_shifted,          &
                                                 cell_orientation_shifted )
         else
          call log_event( "Cell orientation not set up for high order elements", &
                          LOG_LEVEL_ERROR )
        end if

      end if

    end if

    !================= Create a height field =====================!
    ! Note that these fields represent the height relative to
    ! the surface as represented by a sphere.  With the current
    ! representation of chi, this will result in the lowest
    ! levels being -ve. This should be reviewed with ticket #562
    call height_w3%initialise( vector_space = w3_k0_fs )
    call height_wth%initialise( vector_space = wth_k0_fs )
    call invoke( get_height_kernel_type(height_w3, chi_sph), &
                 get_height_kernel_type(height_wth, chi_sph) )


    ! Compute latitude and longitude maps
    call lat_w3%initialise( vector_space = w3_k0_2d_fs )
    call long_w3%initialise( vector_space = w3_k0_2d_fs )
    if ( geometry == geometry_spherical ) then
      call invoke( compute_latlon_kernel_type( lat_w3, long_w3, chi_xyz) )
    else
      call invoke( setval_c(lat_w3, f_lat),  &
                   setval_c(long_w3, 0_r_def) )
    end if

    !================ Create dA values at W2 dof locations ==================!

    call dA_at_w2%initialise( vector_space = w2_fs )
    call invoke( setval_c(dA_at_w2, 0.0_r_def),&
                 calc_dA_at_w2_kernel_type(dA_at_w2, chi_sph, panel_id) )

    !================ Now create all shifted mesh properties =================!

    if ( present(shifted_mesh_id) ) then
      ! Make shifted mesh id globally available
      global_shifted_mesh_id = shifted_mesh_id

      allocate(chi_xyz_shifted(3))
      do i = 1, 3
        call shifted_chi_xyz(i)%copy_field(chi_xyz_shifted(i))
      end do

      allocate(chi_sph_shifted(3))
      do i = 1, 3
        call shifted_chi_sph(i)%copy_field(chi_sph_shifted(i))
      end do

      !======================= Get areas on shifted mesh ======================
      call dA_at_w2_shifted%initialise( vector_space =                                   &
                                   function_space_collection%get_fs( shifted_mesh_id,    &
                                                                     element_order, W2 ) )

      call invoke( setval_c(dA_at_w2_shifted, 0.0_r_def),                   &
                   calc_dA_at_w2_kernel_type(dA_at_w2_shifted, chi_sph_shifted, panel_id) )


      !============== Now create all double level mesh properties ==============!

      if ( present(double_level_mesh_id) ) then
        ! Make shifted mesh id globally available
        global_double_level_mesh_id = double_level_mesh_id

        allocate(chi_xyz_double_level(3))
        do i = 1, 3
          call double_level_chi_xyz(i)%copy_field(chi_xyz_double_level(i))
        end do

        allocate(chi_sph_double_level(3))
        do i = 1, 3
          call double_level_chi_sph(i)%copy_field(chi_sph_double_level(i))
        end do

      !==================== Get areas on double layer mesh ====================!
        call dA_at_w2_double_layer%initialise( vector_space = &
             function_space_collection%get_fs( double_level_mesh_id, &
                                               element_order, W2 )   )

        call invoke( setval_c(dA_at_w2_double_layer, 0.0_r_def), &
                     calc_dA_at_w2_kernel_type(dA_at_w2_double_layer, chi_sph_double_level, panel_id) )

      end if

    end if  ! End shifted mesh properties setup

    nullify( w2_fs  )
    nullify( w3_fs  )
    nullify( wtheta_fs )
    nullify( wth_k0_fs )
    nullify( w3_k0_fs  )
    nullify( w3_k0_2d_fs  )

    call log_event( "Gungho: created geometric_constants", LOG_LEVEL_INFO )
    if ( subroutine_timers ) call timer('geometric_constants_alg')

  end subroutine create_geometric_constants

  !> @brief Returns a pointer to the shifted mesh id
  !> @return The shifted mesh id
  function get_shifted_mesh_id() result(our_mesh_id)
    implicit none
    integer(i_def), pointer :: our_mesh_id

    our_mesh_id => global_shifted_mesh_id
  end function get_shifted_mesh_id

  !> @brief Returns a pointer to the double level mesh id
  !> @return The coordinate field array
  function get_double_level_mesh_id() result(my_mesh_id)
    implicit none
    integer(i_def), pointer :: my_mesh_id

    my_mesh_id => global_double_level_mesh_id
  end function get_double_level_mesh_id

  !> @brief Function to return a pointer to the panel_id
  !> @return The coordinate field array
  function get_panel_id_fine() result(panel_id_ptr)
    implicit none
    type(field_type), pointer :: panel_id_ptr
    panel_id_ptr => panel_id_mg(1)
  end function get_panel_id_fine

  !> @brief Function to return a pointer to the panel_id
  !> @return The coordinate field array
  function get_panel_id_mg(level) result(panel_id_ptr)
    implicit none
    integer, intent(in) :: level
    type(field_type), pointer :: panel_id_ptr
    panel_id_ptr => panel_id_mg(level)
  end function get_panel_id_mg

  !> @brief Returns a pointer to the spherical coordinate array on the finest level
  !> @return The coordinate field array
  function get_coordinates_fine() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)
    coords_ptr => chi_mg(:,1)

  end function get_coordinates_fine

  !> @brief Returns a pointer to the spherical coordinate array on the specified level
  !> @param level integer multigrid level
  !> @return The coordinate field array
  function get_coordinates_mg(level) result(coords_ptr)
    implicit none
    integer, intent(in) :: level
    type(field_type), pointer :: coords_ptr(:)

    coords_ptr => chi_mg(:,level)
  end function get_coordinates_mg

  !> @brief Function to return a pointer to the (X,Y,Z) coordinate array
  !> @return The coordinate field array
  function get_coordinates_xyz() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)
    coords_ptr => chi_xyz

  end function get_coordinates_xyz

  !> @brief Returns a pointer to the coordinate array on the shifted mesh
  !> @return The coordinate field array
  function get_coordinates_shifted() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)

    coords_ptr => chi_sph_shifted(:)
  end function get_coordinates_shifted

  !> @brief Function to return a pointer to the spherically-based coordinate array
  !> @return The coordinate field array
  function get_coordinates_xyz_shifted() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)
    coords_ptr => chi_xyz_shifted

  end function get_coordinates_xyz_shifted

  !> @brief Returns a pointer to the coordinate array on the double_level mesh
  !> @return The coordinate field array
  function get_coordinates_double_layer() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)

    coords_ptr => chi_sph_double_level(:)
  end function get_coordinates_double_layer

  !> @brief Function to return a pointer to the spherically-based coordinate array
  !> @return The coordinate field array
  function get_coordinates_xyz_double_layer() result(coords_ptr)
    implicit none
    type(field_type), pointer :: coords_ptr(:)
    coords_ptr => chi_xyz_double_level

  end function get_coordinates_xyz_double_layer

  !> @brief Returns a pointer to the cell_orientation field
  !> @return The cell_orientation field
  function get_cell_orientation() result(orientation)
    implicit none
    type(field_type), pointer :: orientation

    if (scheme /= scheme_method_of_lines    .or. &
        rho_splitting /= rho_splitting_none .or. &
        theta_splitting /= theta_splitting_none  ) then
      orientation => cell_orientation
    else
      call log_event( "Cell orientation variable has not been created", LOG_LEVEL_ERROR )
    end if

  end function get_cell_orientation

  !> @brief Returns a pointer to the cell_orientation_shifted field
  !> @return The cell_orientation_shifted field
  function get_cell_orientation_shifted() result(orientation_shifted)
    implicit none
    type(field_type), pointer :: orientation_shifted

    if (scheme /= scheme_method_of_lines    .or. &
        rho_splitting /= rho_splitting_none .or. &
        theta_splitting /= theta_splitting_none  ) then
      orientation_shifted => cell_orientation_shifted
    else
      call log_event( "Shifted cell orientation variable has not been created", LOG_LEVEL_ERROR )
    end if

  end function get_cell_orientation_shifted

  !> @brief Returns the dA values at W2 dof locations
  !> @return The dA field
  function get_dA_at_w2() result(dA)
    implicit none
    type(field_type), pointer :: dA
    dA => dA_at_w2

  end function get_dA_at_w2

  !> @brief Returns the dA values at shifted W2 dof locations
  !> @return The shifted dA field
  function get_dA_at_w2_shifted() result(dA)
    implicit none
    type(field_type), pointer :: dA
    dA => dA_at_w2_shifted

  end function get_dA_at_w2_shifted

  !> @brief Returns the double level dA values at W2 dof locations
  !> @return The dA field on double level mesh
  function get_dA_at_w2_double_layer() result(dA)
    implicit none
    type(field_type), pointer :: dA
    dA => dA_at_w2_double_layer

  end function get_dA_at_w2_double_layer

  !> @brief Returns a pointer to a height field
  !> @param[in] space the space of the desired height field
  !> @return A height field
  function get_height(space) result(height)
    implicit none
    integer(i_def), intent(in) :: space
    type(field_type), pointer :: height

    select case (space)
    case (W3)
      height => height_w3
    case (Wtheta)
      height => height_wth
    case default
      height => null()
      call log_event( "Height not available on requested space", LOG_LEVEL_ERROR)
    end select

  end function get_height

  !> @brief Returns a pointer to the latitude map
  !> @return The latitude field array
  function get_latitude() result(lat_ptr)
    implicit none
    type(field_type), pointer :: lat_ptr
    lat_ptr => lat_w3
  end function get_latitude

  !> @brief Returns a pointer to the longitude map
  !> @return The longitude field array
  function get_longitude() result(long_ptr)
    implicit none
    type(field_type), pointer :: long_ptr
    long_ptr => long_w3
  end function get_longitude

  !> @brief Explicitly reclaim memory from module scope variables
  !
  subroutine final_geometric_constants()

    implicit none

    !? Should normal panel id and coordinate fields be deallocated
    if (allocated(chi_sph_shifted)) deallocate(chi_sph_shifted)
    if (allocated(chi_xyz_shifted)) deallocate(chi_xyz_shifted)
    if (allocated(chi_sph_double_level)) deallocate(chi_sph_double_level)
    if (allocated(chi_xyz_double_level)) deallocate(chi_xyz_double_level)
    call cell_orientation%field_final()
    call cell_orientation_shifted%field_final()
    call dA_at_w2%field_final()
    call dA_at_w2_shifted%field_final()
    call dA_at_w2_double_layer%field_final()
    call height_wth%field_final()
    call height_w3%field_final()
    call lat_w3%field_final()
    call long_w3%field_final()

  end subroutine final_geometric_constants

end module geometric_constants_mod
