!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief  Additional code to initialise the linearisation state.
module linear_data_algorithm_mod

  use constants_mod,                  only: i_def, r_def
  use clock_mod,                      only: clock_type
  use gungho_model_data_mod,          only: model_data_type
  use field_mod,                      only: field_type
  use field_collection_mod,           only: field_collection_type
  use linked_list_mod,                only: linked_list_type
  use lfric_xios_read_mod,            only: read_state
  use mr_indices_mod,                 only: nummr
  use moist_dyn_mod,                  only: num_moist_factors
  use moist_dyn_factors_alg_mod,      only: moist_dyn_factors_alg
  use variable_fields_mod,            only: init_variable_fields,  &
                                            update_variable_fields
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO,    &
                                            LOG_LEVEL_DEBUG

  implicit none

  private
  public init_ls_file_alg,        &
         update_ls_file_alg,      &
         combine_ls_winds,        &
         linear_copy_model_to_ls, &
         linear_init_pert_random

  contains

  !> @brief   Read the time-varying linearisation state from a file.
  !> @details Initialise the lin state, that is read in and updated using
  !!          a time-axis.
  !> @param[in,out] ls_times_list  The Lin state time axis list
  !> @param[in]     clock          Clock
  !> @param[in,out] ls_fields      The Lin state field collection
  !> @param[in,out] ls_mr          The Lin state mixing ratios
  !> @param[in,out] ls_moist_dyn   The Lin state moist dynamical factors
  subroutine init_ls_file_alg( ls_times_list, clock, ls_fields, ls_mr, ls_moist_dyn )

    implicit none

    type( field_collection_type ), intent(inout) :: ls_fields
    type( field_type ),            intent(inout) :: ls_mr(nummr)
    type( field_type ),            intent(inout) :: ls_moist_dyn(num_moist_factors)
    type(linked_list_type),        intent(in)    :: ls_times_list
    class(clock_type),             intent(in)    :: clock

    call read_state( ls_fields )
    call init_variable_fields( ls_times_list, &
                               clock, ls_fields )

    call combine_ls_winds( ls_fields )
    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )

  end subroutine init_ls_file_alg

  !> @brief   Update the time-varying Lin state from a file.
  !> @details Update the Lin state, that is read in and updated using
  !!          a time-axis.
  !> @param[in]     ls_times_list  The Lin state time axis list
  !> @param[in]     clock          Clock
  !> @param[in,out] ls_fields      The Lin state field collection
  !> @param[in,out] ls_mr          The Lin state mixing ratios
  !> @param[in,out] ls_moist_dyn   The Lin state moist dynamical factors
  subroutine update_ls_file_alg( ls_times_list, clock, ls_fields, ls_mr, ls_moist_dyn )

    implicit none

    type( field_collection_type ), intent(inout) :: ls_fields
    type( field_type ),            intent(inout) :: ls_mr(nummr)
    type( field_type ),            intent(inout) :: ls_moist_dyn(num_moist_factors)
    type(linked_list_type),        intent(in)    :: ls_times_list
    class(clock_type),             intent(in)    :: clock

    type( field_type ), pointer                  :: ls_field => null()

    call update_variable_fields( ls_times_list,    &
                                 clock, ls_fields )

    ! Combine h_wind (W2h) and v_wind (wtheta) into wind (w2)
    call combine_ls_winds( ls_fields )
    call moist_dyn_factors_alg( ls_moist_dyn, ls_mr )

    ls_field => ls_fields%get_field("ls_u")
    call ls_field%log_minmax(LOG_LEVEL_DEBUG,'ls_u')

    ls_field => ls_fields%get_field("ls_rho")
    call ls_field%log_minmax(LOG_LEVEL_DEBUG,'ls_rho')

    ls_field => ls_fields%get_field("ls_exner")
    call ls_field%log_minmax(LOG_LEVEL_DEBUG,'ls_exner')

    ls_field => ls_fields%get_field("ls_theta")
    call ls_field%log_minmax(LOG_LEVEL_DEBUG,'ls_theta')

  end subroutine update_ls_file_alg

  !> @brief   Combine horizontal and vertical winds.
  !> @details The horizontal winds are read in as W2H, and the vertical
  !!          winds are read in as Wtheta. This combines them into a
  !!          single W2 field.
  !> @param[in,out] fields  The collection of ls fields
  subroutine combine_ls_winds( fields )

    use combine_w2_field_kernel_mod, only: combine_w2_field_kernel_type

    implicit none

    type( field_collection_type ), intent(inout) :: fields
    type(field_type), pointer                    :: wind => null()
    type(field_type), pointer                    :: h_wind => null()
    type(field_type), pointer                    :: v_wind => null()

    write(log_scratch_space,'(A)') "Combining winds "
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    h_wind => fields%get_field("ls_h_u")
    v_wind => fields%get_field("ls_v_u")
    wind => fields%get_field("ls_u")

    call invoke( combine_w2_field_kernel_type(wind, h_wind, v_wind) )

  end subroutine combine_ls_winds

  !> @brief Copy the prognostic fields to the LS and then zero the prognostics.
  !> @param[in,out] model_data The working data set for the model run
  subroutine linear_copy_model_to_ls( model_data )

    implicit none

    type( model_data_type ), target, intent(inout) :: model_data

    type( field_collection_type ), pointer :: prognostics => null()
    type( field_collection_type ), pointer :: ls_fields => null()
    type( field_type ),            pointer :: ls_mr(:) => null()
    type( field_type ),            pointer :: mr(:) => null()
    type( field_type ),            pointer :: ls_moist_dyn(:) => null()
    type( field_type ),            pointer :: moist_dyn(:) => null()
    type( field_type ),            pointer :: l_field => null()
    type( field_type ),            pointer :: n_field => null()
    integer(i_def) :: imr

    write(log_scratch_space,'(A)') "Copy prognostics to ls fields"
    call log_event(log_scratch_space, LOG_LEVEL_INFO)

    ls_fields => model_data%ls_fields
    prognostics => model_data%prognostic_fields

    l_field => ls_fields%get_field("ls_u")
    n_field => prognostics%get_field("u")
    call invoke( setval_X( l_field, n_field), &
                 setval_C( n_field, 0.0_r_def) )

    l_field => ls_fields%get_field("ls_exner")
    n_field => prognostics%get_field("exner")
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    l_field => ls_fields%get_field("ls_rho")
    n_field => prognostics%get_field("rho")
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    l_field => ls_fields%get_field("ls_theta")
    n_field => prognostics%get_field("theta")
    call invoke( setval_X( l_field, n_field) , &
                 setval_C( n_field, 0.0_r_def) )

    ls_mr => model_data%ls_mr
    mr => model_data%mr
    do imr = 1, nummr
      call invoke( setval_X( ls_mr(imr), mr(imr) ) , &
                   setval_C( mr(imr), 0.0_r_def) )
    end do

    ls_moist_dyn => model_data%ls_moist_dyn
    moist_dyn => model_data%moist_dyn
    do imr = 1, num_moist_factors
      call invoke( setval_X( ls_moist_dyn(imr), moist_dyn(imr) ) , &
                   setval_C( moist_dyn(imr), 0.0_r_def) )
    end do

  end subroutine linear_copy_model_to_ls

  subroutine linear_init_pert_random( mesh_id, twod_mesh_id, model_data )

    use assign_field_random_kernel_mod, only: assign_field_random_kernel_type

    implicit none

    integer(i_def),                  intent(in)    :: mesh_id
    integer(i_def),                  intent(in)    :: twod_mesh_id
    type( model_data_type ), target, intent(inout) :: model_data

    integer :: i
    type( field_type ), pointer                    :: field => null()
    type( field_type ), pointer                    :: moist_dyn(:) => null()
    type( field_type ), pointer                    :: mr(:) => null()
    real(r_def) :: gamma_u, gamma_rho, gamma_exner, gamma_theta
    real(r_def) :: gamma_moist_dyn, gamma_mr

    gamma_u = 1.e4
    gamma_theta = 1.e2
    gamma_rho = 1.e-1
    gamma_exner = 1.e-1
    gamma_moist_dyn = 1.e-1
    gamma_mr = 1.e-1

    field => model_data%prognostic_fields%get_field("u")
    call invoke( assign_field_random_kernel_type( field ))
    call invoke( inc_a_times_X( gamma_u, field ))

    field => model_data%prognostic_fields%get_field("rho")
    call invoke( assign_field_random_kernel_type( field ))
    call invoke( inc_a_times_X( gamma_rho, field ))

    field => model_data%prognostic_fields%get_field("theta")
    call invoke( assign_field_random_kernel_type( field ))
    call invoke( inc_a_times_X( gamma_theta, field ))

    field => model_data%prognostic_fields%get_field("exner")
    call invoke( assign_field_random_kernel_type( field ))
    call invoke( inc_a_times_X( gamma_exner, field ))

    moist_dyn => model_data%moist_dyn
    do i = 1, num_moist_factors
      call invoke( assign_field_random_kernel_type( moist_dyn(i) ) )
      call invoke( inc_a_times_X( gamma_moist_dyn, moist_dyn(i) ))
    end do

    mr => model_data%mr
    do i = 1, nummr
      call invoke( assign_field_random_kernel_type( mr(i) ) )
      call invoke( inc_a_times_X( gamma_mr, mr(i) ))
    end do

  end subroutine linear_init_pert_random

end module linear_data_algorithm_mod
